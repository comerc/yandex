```go
// if i := 0; i == 0 {} - присваивание; условие
// a := [5]any{"1", 2, true} - кортеж (tuple)
// l := t[:] - не меняет unsafe.Pointer
// l := t[1:2:3] - третий член определяет ёмкость
// cap() - для массивов, как алиас на len()
// cap() - применим для слайсов и каналов (буферизированный канал имеет len & cap)
// for i, ch := range s {} "go" - ch имеет тип rune, s имеет тип string (т.е. range итерирует строку рунами); но i возвращает не индекс руны, а начальный индекс руны в []byte(s)
// for i, r := range []rune(s) {} - тогда i возвращает индекс руны; но сложность O(n), где n — количество байтов в строке
// utf8.RuneCount / utf8.RuneCountInString - альтернатива `len([]rune(s))`
// ch := make(chan string) - блокирует передатчик, пока не готов приёмник
// bufferedCh := make(chan string, 1) - неблокирует передатчик, пока не готов приёмник
// make(<-chan bool) / make(chan<- bool) - ответ на вопрос: зачем создавать каналы только для чтения / записи? и ещё: канал только на чтение невозможно закрыть!
// j, ok := <-jobs - проверка, что канал закрыт
// for t := range ticker.C {} - чтение из канала ticker.C
// важно запускать wg.Add(1) в том же потоке (или родительском), где и wg.Wait()
// time.Tick() - лучше не использовать, it "leaks"; вместо него NewTicker() + Stop()
// myType(val) - приведение типа работает, если известен тип для val
// val.(myType) - утверждение типа работает, если тип для val неопределён (т.е. interface{})
// var i int; defer func(i int) { println(i) }(i); i = 1 - выведет 0
// var i int; defer func(i *int) { println(*i) }(&i); i = 1 - выведет 1
// var i int; defer func() { println(i) }(); i = 1 - выведет 1
// func test() (x int) { defer func() { x++ }(); x = 1; return } - выведет 2
// есть ли в стандартной библиотеке пакет для работы с коллекциями разных типов через дженерики?
// [Лучший regexp для Go](https://habr.com/ru/articles/756222/)
// regexp.MustCompile() для глобальных переменных вместо regexp.Compile()
// type MyType struct { Page int `json:"page"` } - поле публичное (с большой буквы) + "json-тег структуры"
// diff := time.Now().Sub(other) - разница между двумя временами
// time.Now().Add(-diff) - продвинуть время на заданную продолжительность
// u, _ := url.Parse(s); net.SplitHostPort(u.Host) - как вытащить порт
// ew := &errWriter{Writer: w} - где errWriter реализует свой метод Write с предварительной обработкой сохранённой ошибки https://habr.com/ru/articles/759920/
// os.RemoveAll("dir") - аналог "rm -rf"
// go test -v - флаг -v отображает прохождение тестов
// go test -run="VectorA.*$|TestVectorMag" -v - применение regex для фильтра тестов
// [fuzzing-тесты](https://habr.com/ru/companies/oleg-bunin/articles/709248/)
// testify - в помощь по тестированию к стандартной библиотеке
// mockery - для тестов
// [migrate](https://github.com/golang-migrate/migrate)
// flag - стандартный пакет, плюс выбор: flaggy 840 | go-flags 2500 | pflag 2200
// exec.Command("bash", "-c", "ls -a -l -h") - как создать полную команду в одну строку вместо exec.Command("ls", "-a", "-l", "-h")
// os.Exit(1) - игнорирует defer
// цветные логи: https://github.com/GolangLessons/url-shortener/blob/c3987f66469a8d0769add18521adb9023520be95/internal/lib/logger/handlers/slogpretty/slogpretty.go
// vegeta, wrk - для стресс-тестов
// когда нужен готовый сервер httpserver - https://github.com/evrone/go-clean-template/tree/master/pkg/httpserver
// allegro/bigcache - когда нужен просто кеш (рекомендации лучших собаководов из Avito)
// go-playground/validator - правильный валидатор
// func New(ctx context.Context, connectionString string, opts ...Option) (*Storage, error) - паттерн опций для конструктора в функциях
// tdlibClient.GetMessage(&client.GetMessageRequest{}) паттерн опций для методов в структуре
// благодатное выключение - Graceful Shutdown
// func New() или func NewSubscriber() для пакета subscriber ? нет, например: errors.New
// signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM) - неправильно, signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM) - правильно. os.Interrupt == syscall.SIGINT
// "божественный конфиг" - https://youtu.be/0Fhsgmz-Gig?list=PLZvfMc-lVSSO2zhyyxQLFmio8NxvQqZoN&t=906 (тезис - "разделяй и властвуй")
// ilyakaznacheev/cleanenv - yaml & env в одном флаконе + godotenv для чтения .env
// если функция кидает панику, то у неё должен быть префикс Must*, например MustLoad()
// TEST EXPLORER внутри VS Code
// jackc/pgx/v5/pgxpool / go-pg + pool - PG Pool
// Masterminds/squirrel - SQL Builder (by Avito)
// [Dependency Injection](https://youtu.be/0Fhsgmz-Gig?list=PLZvfMc-lVSSO2zhyyxQLFmio8NxvQqZoN&t=1001)
// [Dependency Injection на примере Uber fx](https://www.youtube.com/watch?v=KRdrH9a98HQ)
// [Learn Go with Tests - Dependency Injection](https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/dependency-injection)
// внутри interface ненужно прописывать ключевое слово func
// er := errgroup.Group{}; eg.SetLimit(limit) - ещё один примитив синхронизации (golang.org/x/sync/errgroup) - кейс применения: если одна из горутин группы завершится с ошибкой, то остановятся все.
// math.Pow() - возведение в степень
// for i := range n - можно выпонять инкремент по числу (начиная с 1.22)
// механизм эвакуации в map (про бакеты и их переполнение)
// RWMutex - читаем без блокировок на чтение, но с блокировкой на запись при чтении(!), или записи (но сильно дороже, чем просто Mutex - механизм блокировки примерно на 30%; имеет смысл, если преобладает чтение над записью, т.к. чтение легковесное)
// map в Go не гарантирует порядок ключей (что даёт большую свободу разработчикам - никто не сможет этим воспользоваться), ES6 - гарантирует, а Dart - нет (hash map vs b-tree map); reflect.DeepEqual() при перестановке ключей-значений вернёт true для map, но false - для слайсов/массивов (т.к. там порядок членов гарантирован).
// log.Fatal(http.ListenAndServe(":8080", httpserver.NewHandler())) - как вариант обработки ошибок, но профит сомнительный - мы же выходим из программы без стека ошибок (os.Exit)
// "божественный" main.go - это прекрасно, каждый раз так делаю и всем советую
// string - это тоже структура и лежит в куче; при передаче аргументом, что копируется? строка неизменяемая. структура из двух полей - ссылка на массив байтов и len (дешевле, чем слайс - нет третьего поля cap - 16 vs 24 байт)
// func (Bear) Speak() - можно не указывать "this" в рессивере при реализации метода структуры (что полезно для псевдостатических методов)
// Интерфейсы - способ, как сделать программу SOLIDной? (Dependency Inversion)
// где лучше объявлять интерфейсы: где применяются или где реализуются? (утиная типизация даёт больше свободы: для инхаус разработки выгодно все интерфейсы выделить в отдельном месте; а если реализуешь бизнес логику в гексагональной архитектуре, то лучше применять интерфейсы, как порты - т.е. на своей стороне)
// что не нравится в Go? имплементация методов интерфейса в отрыве от объявления интерфейса, т.е. отсутствует самодокументирование кода, как например в Dart: class MyClass implements MyInterface {}
// type (A struct {}; B struct {}) - типы можно объявлять группой
// go run . | ts '%.Ss' - не работает с println(), только с fmt.Println()
// gherkingen - для BDD
// пакеты и папки - вместо пробелов применяется тире, а файлы - подчёркивания
// go test - это интерпретатор, а значит реализуем функционал, подобный WallabyJS
// что не нравится в Go? импорт без алиасов (как было в TypeScript)
// что не нравится в Go? требуется явную передачу контекста аргументом в функциях
// что не нравится в Go? отсутствует интерполяция строк
// что не нравится в Go? Горутина — это такой же ресурс, как и любой другой, который должен быть закрыт для освобождения памяти или других ресурсов. При этом нет какого-либо идеоматичного решения, типа как defer для освобождения ресурсов.
// type MyClass struct { lock sync.Mutex } - ненужно инициализировать lock, тут работает "ленивая инициализация"
// v := [...]int{5: 0} - что лежит в v?
// break внутри case в select / switch - выйдут из области видимости select / switch (а не прервут for)
// повторить Go Cuncurrency Patterns https://github.com/Konstantin8105/Go-pipelines
// повторить Go Cuncurrency Patterns https://habr.com/ru/companies/otus/articles/722880/
// pipe in GoLang like Elixir https://devevangelista.medium.com/functional-programming-in-go-an-adventure-with-gofn-and-pipe-de42b3a76449
// - вкурить: quicksort, mergesort, heapsort, сортировка вставками и пузырковая сортировка
// type Counter struct { data chan int } (или var data chan int) - когда объявляем канал, не обозначить буферизированный он, или нет (т.к. буферезация - часть инстанса)
// type MyType struct { k1 int; k2 int } - можно инициализировать не все именованные поля, например: v := MyType{k1:123}; v := MyType{k2:123}
// for range done {} вместо <-done
// - научиться готовить новый пакет slices (v1.21)
// как получить доступ на внутренний массив слайса? a := []int{1,2,3}; *(*[3]int)(unsafe.Pointer(&a[0]))
// - [Go в Domain Driven Design](https://youtu.be/JcsKI7QyDrs)
// - [Understanding Real-World Concurrency Bugs in Go](https://songlh.github.io/paper/go-study.pdf) [Как не ошибиться с конкурентностью в Go](https://www.youtube.com/watch?v=4U3EaVufuW4)
// interval := 0 * time.Second - распространённая идиома для инициализации переменной типа time.Duration с нулевым интервалом времени
// GetWorkDir() - ex := os.Executable() >> dir := filepath.Dir(ex) >> strings.Contains(dir, "go-build") - как способ узнать: go build / go run
// time.AfterFunc - возможность вызвать callback
// go увеличивает capacity только при append, но не на обрезаниях
// a := []int{1, 2}; a = append(a, []int{3, 4, 5}...); println(cap(a)) // 6 - прибавляет всегда чётное число, равное len(a) или больше на 1. Фокус, когда добавляемых элементов больше, чем размер исходного слайса. При этом финальный размер должен быть больше либо равен 5. Ответ: alignUp rounds n up to a multiple of a. a must be a power of 2. Дополнительно: https://habr.com/ru/articles/660827/
// for n := range ch {} - классическая ошибка - забыть закрыть канал, тогда будет блокировка типа <-done без пары записи в канал
// префикс must обычно используется в функциях, которые могут вызвать панику
// для модульных/интеграционных-тестов package не менять (иначе, только ради тестов открываю все внутренности в API модуля - это неправильно, только добавляет когнитивную нагрузку в Developer Experience), а для приёмочных выносить в отдельный package с суффиксом _test, что заставляет определить API модуля.
// io.Discard - заглушка для io.Writer (например, для ускорения тестов)
// var _ MyInterface = (*MyStruct)(nil) - как с помощью типизированного nil можно проверить, что тип структуры реализует интерфейс, не создавая инстанс этой структуры
// [Compile-time Dependency Injection for Go](https://github.com/google/wire)
// [Fx is a dependency injection system for Go](https://github.com/uber-go/fx)
// https://github.com/uber-go/zap
// https://github.com/golangci/golangci-lint
// https://github.com/uber-go/config
// https://github.com/go-telegram-bot-api/telegram-bot-api
// вызов r.Context() внутри обработчика для http.NewServeMux()
// sync.TryLock (начиная с 1.18)
// slices.Clip (начиная с 1.21) - уменьшает capacity слайса до его текущей длины - имеет смысл пробовать после 10Мб https://www.youtube.com/watch?v=G-lhh_1XNcI
// type parameters VS generics - зачем два термина? Таким образом, “type parameters” и “generics” относятся к различным аспектам одной и той же функциональности. “Generics” относится к общей концепции написания кода, который может работать с различными типами, в то время как “type parameters” относится к конкретному механизму, используемому для реализации этой функциональности.
// `func F[T ~int](i T) {}` - approximation element (добавление тильды), допускает `int` и `type MyInt int` (требуемый базовый тип)
// как запомнить Itoa & Atoi из пакета strconv: (Integer to ASCII) & (ASCII to Integer)
// как озвучить type M[T any] []T - дженерик для слайса, определяемый параметром типа
// почему параметры типа в Go обозначают в квадратных скобочках, а не в треугольных, как в других языках?
// А можно сказать, что "approximation element" для параметров типа в дженериках - это LSP из SOLID? Нет.
// x, y = "1", 2 - называется "присваивание кортежу" в Python, но в GoLang это "множественное присваивание"
// UTF-8 - принятая кодировка в Go (авторы Ken Thompson и Rob Pike), которая описывает рунами символы из unicode.org, где каждая руна может иметь разную длину от одного до четырех байтов, в отличии от кодировки UTF-32 (фиксированный размер int32), и UTF-16 - это кодировка фиксированной длины, которая использует два или четыре байта. но `rune // alias for int32`
// генератор констант iota
// нетипизированные константы
*****
// type MyInt int - "именованный тип", может применяться "анономным полем" через механизм "embedded": type MyObj struct { MyInt }; println(MyObj{1}.MyInt)
// type Event struct {ID int; time.Time}; event := Event{ID: 1234, Time: time.Now()} - инициализация "анонимного поля"
// type MyType struct {}; func (a *MyType) Try() { if a == nil { println("nil") } }; var a *MyType; a.Try(); - подобие статического метода класса
// type MyType struct{}; func (a *MyType) Try() {}; var a *MyType; try := (*MyType).Try; try(a); - выражение-метод, работает и с (*MyType).Try и с MyType.Try в зависимости от того, как передаётся рессивер ("значение-метод" - это метод в переменной от инстанса, "выражение-метод" - это метод в переменной от типа)
// var _ io.Writer = (*bytes.Buffer)(nil) - проверка без создания экзепляра, что *bytes.Buffer реализует интерфейс io.Writer
// Методы, определенные для типа T, также доступны для указателей этого типа (*T). Однако обратное неверно: методы, определенные для *T, недоступны для T.
// интерфейсный тип не даёт типизированный nil: var w io.Writer = nil // <nil> VS var w *os.File = nil // (*os.File)(nil)
// func fn(out io.Writer) { if out != nil { ... } } - потенциальная ошибка, если передать типизированный nil, например var buf *bytes.Buffer
// var x any = []int{1, 2, 3}; println(x == x) - какой линтер может отлавливать эту ситуацию? Сравнивайте значения интерфейсов, только если вы уверены, что они содержат динамические значения сравниваемых типов.
// type Interface interface - "базовый" интерфейс модуля называется Interface (например: sort.Interface)
// rw := w.(io.ReadWriter) - panic: interface conversion; rw, ok := w.(io.ReadWriter) - ok == false
// io.WriteString - это рекомендованный способ записи строки в io.Writer
// switch t := v.(type) - .(type) работает только внутри "type switch"
// fallthrough - "проваливаться" - переход в следующий case (без его проверки), или в default
// switch x := x.(type) { case nil: return "NULL" } - при выборе типа можно проверять на nil; в выборе типа применение fallthrough не разрешено
// switch без условия полезен тем, что может использоваться для проверки нескольких условий
// switch без условий эквивалентен switch true, т.е. switch { case true: println("OK") }
// при чтении для канала можно использовать `value, ok := <-ch`
// https://github.com/mcfly722/context
// func fn(x, y int) int - сигнатура функции (для Go - вместе с возвращаемым типом)
// fn := func(x, y int) int { return x * y } - то, что присваивается fn, называется "литералом функции"
// `const dog = { name: 'Naya', sex: 'female', age: 2, breed: 'Rottweiler mix' };` - объектный литерал в JavaScript; по аналогии в GoLang есть понятия "литерал структуры" и "литерал карты". В компьютерных науках литерал - это текстовое представление значения, так как оно записано в исходном коде. a := 1; // 1 - это целочисленный литерал s := "cat"; // "cat" - это строковый литерал
// у каждого пакета должна быть своя отдельная директория
// Python также поддерживает возврат нескольких значений из функции, подобно Go
// guard clauses - "защитные оговорки", это когда в теле функции сначала проверяю условия и выхожу при их обнаружении, а только потом вычисляю основной вариант (вместо вложенного ветвления if-ов); а ещё это полезно для концепции встраивания быстрого пути (fast-path inlining)
// myCar := struct{ make, model string }{"tesla", "model3"} - анонимная структура; может применяться для вложенности структур
// sum(nums ...int) - вариативная функция (variadic function), где nums - слайс, ... - spread operator; sum(nums...) - при вызове тоже можно использовать ... - slice unpacking
// каналы можно в мапы в качестве ключей, т.к. это сравниваемый тип
// как получить руну в строке по индексу: `s := "👻abc"; runes := []rune(s); println(string(runes[1]))`
// `var a *int; b := *a` - разименование nil-указателя приведёт к panic
// `go build` в директории локального пакета выполнит кеширование для дальнейшей сборки модуля
// `go install` выполнит сборку и установку модуля локально в системе в `GOPATH`, хотя всё остальное про `GOPATH` - устарело
// replace внутри go.mod: `replace example.com/username/module v0.0.0 => ../module` (альтернатива `go work init` начиная с go1.18)
// для модулей go не нужен какой-то внешний реестр модулей (как npm в javascript, например)
// закрытие канала приводит к широковещательному оповещению всех слушателей (в отличии от передачи данных по каналу - "кто первый встал, того и тапки"); но следует учитывать, что при закрытии буферизованного канала, сначала будут прочитаты все оставшиеся значения.
// sync.Cond тоже умеет в широковещательное оповещение всех слушателей - .Broadcast()
// `v, ok := <-ch` - ok сообщает, получилось ли прочитать из канала (а не "канал открыт/закрыт"); только когда в (закрытом) буферизованном канале не осталось значений: v == 0, ok == false
// `for v, ok := range ch {}` - ok для каналов не имеет смысла (не компилируется), а тут работает: `select { case v, ok := <-ch: }`
// порядок case-элементов в select не имеет значения (равномерный псевдослучайный выбор)
// функции init в одном пакете отрабатывают в порядке названий файлов пакета
// В большинстве случаев возвращать (из функции/метода) лучше не интерфейсы, а конкретные реализации (error - исключение); и наоборот, функции должны принимать интерфейсы всегда, когда это возможно. (а если возвращать интерфейс, то по указателю; например, паттерн "фабричный метод"). Возврат интерфейса, как правило, ограничивает гибкость, поскольку мы заставляем всех потребителей использовать один конкретный тип абстракции.
// var i *int - не инициализирует числовое значение, как 0.
// sum := 100 + 010 // 108 - целочисленный литерал, начинающийся с 0, считается восьмеричным целым числом; чтобы улучшить читаемость и избежать потенциальных ошибок, сделайте восьмеричные числа явными, используя префикс 0o
// можно использовать символ подчеркивания (_) в качестве раздели- теля для удобства чтения; например, записать 1 миллиард так: 1_000_000_000.
// var l, r int; mid := int(uint(l+r) / 2) - борьба с переполнением: https://www.bugsnag.com/blog/bug-day-ariane-5-disaster/
// `var a []int; b := append(a, 1)` или `b := append([]int(nil), 1)` - append работает с nil-срезом
// пустоту среза/карты всегда следует проверять через len(), чтобы избежать разницу между пустым и нулевым срезом/картой
// если мы хотим выполнить полное копирование через copy(), второй срез должен иметь длину больше или равную длине исходного
// `s1 := []int{1, 2, 3}; s2 := s1[1:2]; s3 := append(s2, 10)` побочный эффект: `s1=[1 2 10], s2=[2], s3=[2 10]`; как этого избежать: `s2 := s1[1:2:2]`
// В качестве эмпирического правила запомните, что нарезка большого среза или массива может потенциально привести к высокому потреблению памяти. Остающееся в памяти пространство не будет восстановлено сборщиком мусора, и мы можем сохранять в памяти очень большой резервный массив, несмотря на использование только нескольких элементов. Использование копии среза — это способ предотвращения такой ситуации.
// make для map задаёт только начальный размер, make для slice - начальный размер и ёмкость
// операция умножения не имеет приоритета над операцией деления, т.е. нужны скобки: b/(1024*1024)
// `m := make(map[int][129]byte)` Если ключ или значение превышает 128 байт, Go не будет хранить их непосредственно в сегменте карты. Вместо этого хранится указатель — для ссылки на ключ или на значение. Если меньше 128 байт, то лучше применять указатель: `m := make(map[int]*[128]byte)` (ошибка #28)
// как сравниваются каналы на == или !=: были ли два канала созданы одним и тем же вызовом функции make либо равны ли оба канала nil
// как сравниваются интерфейсы на == или !=: имеют ли два интерфейса одинаковые динамические типы и одинаковые динамические значения либо равны ли оба интерфейса nil
// `c := make(chan int, 1); close(c); select { case c<-1: }` - select может попытаться записать в закрытый канал, что приведёт к panic; т.е. тут недостаточно закрыть канал, нужно его сбросить в nil (c = nil)
// приоритизация в select: https://stackoverflow.com/questions/11117382/priority-in-go-select-statement-workaround
// `for i, v := range &a { a[i] = 1; print(v) }` - range принимает указатель на массив, чтобы увидеть изменения v (вместо print(a[i]))
// Если запись карты создается во время итерации, она может быть произведена во время итерации или пропущена. Выбор может варьироваться для каждой созданной записи и от одной итерации к другой.
// break loop VS goto next; `loop:` перед for: `loop:for{switch{case true: break loop}}` или `next:` после for: `for{switch{case true: goto next}}next:`
// Важное правило, о котором следует помнить, заключается в том, что оператор break завершает выполнение самого последнего оператора for, switch или select.
// continue тоже можно использовать с меткой
// символ: 汉; кодовая точка unicode (или rune): U+6C49; кодирование тремя байтами в UTF-8: 0xE6, 0xB1, 0x89
// format 'verbs' (спецификаторы формата) https://pkg.go.dev/fmt
// не путать TrimLeft/TrimRight VS TrimPrefix/TrimSuffix (из пакета strings)
// для конкаценации строк в циклах (более 5 строк) лучше использовать strings.Builder и его методы: .WriteString, .Write, .WriteByte, .WriteRune, .Grow (будущая длина среза / capacity)
// Нельзя сравнивать []int{1,2,3} == []int{1,2,3}, в отличии от [3]int{1,2,3} == [3]int{1,2,3}
// uuid := strings.Clone(log[:36]) - копирование строки для предотвращения утечки памяти
// именованные параметры результата метода в интерфейсе совместимы с безимянной реализацией
// не используй имя файла в качестве входных данных функции, вместо этого применяй абстракцию io.Reader
// Вызов функции recover() для перехвата паники горутины полезен только внутри функции defer; в противном случае функция просто вернет nil и более ни на что не будет влиять.
// `return fmt.Errorf("bar failed: %w", err)` - оборачивание ошибки, обратная операция `errors.Unwrap`
// Сигнальная ошибка (sentinel error) — это ошибка, определенная как глобальная переменная: `var ErrFoo = errors.New("foo")`. Понятие "ожидаемая ошибка" (например: io.EOF, sql.ErrNoRows) реализуется в виде значений (сигнальных ошибок); против понятия "непредвиденная ошибка" - реализуется в виде `type BarError struct { ... }`, где BarError реализует интерфейс error.
// если вы уверены, что ошибку можно и нужно игнорировать, то делайте это явно, присвоив ее пустому идентификатору. `_ = notify()` где `func notify() error`
// как передать err из defer в вызывающую функцию выше? через именованный параметр результата: `func fn() (err error) { defer func() { err = errors.New("error!") }() return }`
// Конкурентность — это о работе с большим количеством вещей одновременно. Параллелизм — это о выполнении множества дел одновременно. Роб Пайк
// Каналы — оркестрируют (конкурентные горутины), мьютексы — сериализируют (параллельные горутины)
// канал — это механизм для передачи сигналов с данными или без них; управляющий канал, или канал уведомлений (notification channel) - это канал без данных (struct{}{})
// atomic.LoadInt64() & atomic.StoreInt64() & type atomic.Value
// mutex - образовано от "mutual exclusion"
// преобразование типов не является атомарной операцией в контексте гонок данных
// Гонка данных происходит, когда несколько горутин одновременно обращаются к одной и той же ячейке памяти (например, к одной и той же переменной) и по крайней мере одна из горутин выполняет запись. Важно понимать, что отсутствие гонки данных необязательно будет выдавать детермирнированный результат (состояние гонки - отдельное понятие).
// Функция runtime.GOMAXPROCS() в Go устанавливает максимальное количество CPU, которые могут одновременно выполнять код на уровне пользователя. Однако это не строгое ограничение. Если горутина блокируется (например, системным вызовом), может быть запущен новый поток. Таким образом, даже если GOMAXPROCS установлен в 1, горутины все равно могут работать параллельно, если они блокируются. Стоит отметить, что по умолчанию GOMAXPROCS устанавливается равным количеству доступных логических процессоров. Установка его выше, чем количество доступных процессоров, может привести к большему количеству переключений контекста, если есть больше активных потоков, чем ядер.
// Лучшей практикой при обработке контекстных ключей будет создание неэкспортируемого пользовательского типа: `type key string; const myCustomKey key = "key"; ctx := context.WithValue(context.Background(), myCustomKey, "val")`
// Если вы сомневаетесь, какой контекст использовать, выбирайте context.TODO() вместо передачи пустого контекста с помощью context.Background()
// данные из контекста обычно вытаскивают в middleware - сначала делаем next.ServeHTTP(w, r), потом пишем в кафку
// signal.NotifyContext возвращает копию родительского контекста, которая помечается как выполненная (ее канал Done закрыт) при поступлении одного из перечисленных сигналов, при вызове возвращаемой функции stop или при закрытии канала Done родительского контекста, в зависимости от того, что произойдет раньше.
// замыкание — это функция, которая ссылается на переменные вне своего тела
// GOEXPERIMENT=loopvar избавит от хака для циклов `i := i`
// `var s = struct{}{}` Почему не следует использовать пустой интерфейс (var i interface{})? Потому что пустой интерфейс имеет ненулевой объем. Он занимает 8 байт в 32-битной архитектуре и 16 байт в 64-битной архитектуре. А пустая структура занимает 0 байт.
// запись/чтение отдельных ячеек в слайсе/массиве (но не в мапе) - потокобезопасно (не вызывает гонку данных)
// эти типы sync не должны копироваться: .Cond, .Map, .Mutex, .RWMutex, .Once, .Pool, .WaitGroup
// Когда вызов time.After повторяется (например, в цикле, в функции-потребителе Kafka или в обработчике HTTP), это может привести к пику в потреблении памяти. В таком случае используйте time.NewTimer.
// термины: кодирование (маршалинг) и декодирование (демаршалинг) данных JSON
// Операционная система поддерживает два разных типа часов: настенные (wall clock) и монотонные (monotonic clock). `time.Now()` содержит оба типа часов, а маршалинг данных JSON - только "wall clock". `time.Now().Truncate(0)` - способ сбросить "monotonic clock"
// t := time.Now().In(location) - время для определённого местоположения
// демаршалинг чисел any преобразуется в тип float64
// sql.Open может просто проверять правильность и действительность своих аргументов, не создавая соединение с базой данных (первое соединение может быть открыто лениво). Чтобы убедиться в доступности БД, применяйте метод Ping/PingContext.
// Stmt is a prepared statement (подготовленный оператор): `stmt, err := db.Prepare("SELECT * FROM ORDER WHERE ID = ?"); rows, err := stmt.Query(id); stmt.Close()`; если требуется предоставление какого-то дополнительного контекста: PrepareContext и QueryContext.
// `(sql.Rows).Next` подготавливает следующую строку результата для чтения методом `(sql.Rows).Scan`. Возвращается true в случае успеха или false, если следующая строка результатов отсутствует или при ее подготовке произошла ошибка. Чтобы отличить эти два случая, следует обратиться к `(sql.Rows).Err`.
// Все структуры, реализующие интерфейс io.Closer, в какой-то момент должны быть закрыты: `(sql.Rows).Close`, `(sql.Stmt).Close`, `(sql.DB).Close`, `(os.File).Close`, `(http.Response.Body).Close`
// `*http.Response.Body`, который возвращает `(http.Client).Get`, нужно закрывать после чтения методом `Close` (чтобы не оставлять утечку ресурсов); а если `(http.Client).Post` - тело ответа должно быть закрыто независимо от того, читаем ли мы его.
// Преимущество использования тегов сборки заключается в том, что можно выбирать, какие виды тестов выполнять. Запуск тестов с каким-то тегом включает в себя исполнение как файлов без тегов, так и файлов, соответствующих тегу. Например: `//go:build integration` + `go test --tags=integration -v .`
// Теги сборки имеют один главный недостаток: отсутствие сигналов о том, что тест проигнорирован. Переменная среды + (testing.T).Skip - способ сообщить о пропуске теста. Например: `if os.Getenv("INTEGRATION") != "true" { t.Skip("skipping integration test") }`
// `(testing).Short` + `go test -short -v .` - короткий режим для пропуска длительных тестов.
// если какой-то конкретный файл содержит тесты, которые приводят к гонке данных, мы можем исключить его из обнаружения гонок с помощью тега сборки `//go:build !race`
// (testing.T).Parallel() - метка о том, что тест должен выполняться параллельно
// `go test -parallel 16 .` - можно изменить GOMAXPROCS для запуска тестов параллельно
// `go test -shuffle=on -v .` - флаг для рандомизации тестов, то есть их выполнения в случайном порядке. возможные значения: on, off, seed (для повторного воспроизведения)
// (testing.T).FailNow() - FailNow помечает функцию как не выполнившуюся и останавливает ее выполнение вызовом runtime.Goexit (при этом выполняются все отложенные вызовы в текущей горутине).
// runtime.Goexit() - Goexit завершает вызывающую его горутину. Никакие другие горутины не затрагиваются. Goexit выполняет все отложенные вызовы перед завершением работы горутины. Поскольку Goexit не является паникой, все вызовы восстановления в этих отложенных функциях вернут nil. Вызов Goexit из главной горутины завершает эту горутину без возврата func main. Поскольку функция func main не вернулась, программа продолжает выполнение других программ. Если все остальные горутины завершаются, то программа терпит крах.
// (testing.B) .ResetTimer() .StopTimer() .StartTimer() - сбрасывает таймер бенчмарка
// bench perflock может ограничивать ресурсы CPU, которые может потреблять бенчмарк (только под Linux)
// `func TestMain(m *testing.M) { os.Exit(m.Run()) }` - Чтобы выполнять настройку и демонтаж каждого пакета, используйте функцию TestMain (применимо для интеграционных тестов).
// Wes Dyer: "Сделайте его правильным, сделайте его чистым, сделайте его кратким, сде- лайте его быстрым — именно в таком порядке".
// Принцип локальной ссылки (locality of reference): пространственная локализация кэша (будет сделано какое-то обращение к близлежащим ячейкам памяти), временная локализация кэша (к этому же месту памяти будет снова сделано какое-то обращение).
// Кэш-линия — это непрерывный сегмент памяти фиксированного размера, обычно 64 байта (8 переменных int64).
// Как процессоры работают с данными: Unit stride, Constant stride, Non-unit stride, Critical stride (следует избегать, но пример из книжки не воспроизводится, видимо Go продвинулся в решении вопросов кеширования). Предсказуемость поведения кода для CPU также может быть эффективным способом оптимизации определенных функций. Например, единичный или постоянный шаг предсказуем для CPU, а неединичный шаг (например, связ- ный список) непредсказуем. Чтобы избежать критических шагов и, следовательно, использования только крошечной части кэша, имейте в виду, что кэши разбиваются на сектора.
// Знание того, что более низкие уровни кэша CPU не используются совместно всеми ядрами, помогает избежать снижающих производительность паттер- нов конкурентного кода, например ложного совместного использования. Совместное использование памяти — это иллюзия.
// Используйте параллелизм на уровне инструкций (ILP) для оптимизации определенных частей кода, чтобы CPU мог выполнять как можно больше инструкций параллельно. Выявление опасностей данных — один из основных моментов, связанных с этим.
// Внутри CPU используется протокол MESI, гарантирующий когерентность кэша. Он отслеживает каждую кэш-линию, помечая ее как измененную, эксклюзивную, совместно используемую или недействительную (Modified, Exclusive, Shared и Invalid).
// Как уменьшить объем резервируемой памяти под выравнивания? Эмпирическое правило: реорганизовать структуру так, чтобы ее поля сортировались по размеру типов в порядке убывания.
// Совместно используемые переменные, определенные в функции, которая вызывается из основного фрагмента кода (sharing up), отправляются в кучу. Как правило, совместно используемые переменные, определенные во фрагменте основного кода (sharing down), остаются в стеке. Если компилятор не может доказать (в результате escape-анализа), что переменная не используется после возврата из функции, то место для переменной выделяется в куче. Например: у каждой горутины свой стек, а куча общая для всех; глобальная переменная отправляется в кучу, т.к. к ней могут обращаться несколько горутин.
// `$ go build -gcflags "-m=2"` - флаг для обнаружения "escapes to heap"
// `//go:noinline` - запрет компилятору на inlining-оптимизацию
// Какие примитивы синхронизации знаете? sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Cond, sync.Once, sync.Pool, sync/atomic
// `runtime.SetBlockProfileRate(1)` - включает профилировщик блокировок
// `runtime.SetMutexProfileFraction(1)` - включает профилировщик мьютексов
// `$ go tool pprof -http=:8080 -diff_base heap1 heap2` - исследовать diff для кучи
// `/debug/pprof/heap?gc=1` - запускает GC
// `$ go tool pprof -http=:8080 file` - исследовать file
// `$ go test -bench=. -cpuprofile file` - можно включить профилировщик CPU, используя флаг -cpuprofile, например, при запуске бенчмарка.
// `/debug/pprof/goroutine/?debug=2` - полный дамп стека горутин: `goroutine 2494290 [chan receive, 1420 minutes]`
// `pprof.Do(ctx, pprof.Labels(labels...), fn)` - можно прикреплять ярлыки к различным функциям
// планировщик vs трассировщик - первый анализирует, а второй логирует
// `$ go test -bench=. -v -trace=trace.out` - трассировка бенчмарка: `$ go tool trace trace.out`
// Если вспомогательный сборщик мусора (periodic scavender) недостаточно быстр, можно принудительно вернуть память в распоряжение ОС, используя `debug.FreeOSMemory()`.
// Переменная среды GOGC определяет тот процент роста кучи с момента последней сборки мусора, достижение которого должно запускать следующий цикл GC; ее значение по умолчанию — 100%. Посмотрим пример. Предположим, что сборщик мусора запустился только что, а текущий размер кучи составляет 128 Мбайт. Если GOGC=100, то следующая сборка мусора запустится, когда размер кучи достигает 256 Мбайт. По умолчанию GC выполняется каждый раз, когда размер кучи удваивается. Кроме того, если сборка мусора не выполнялась в течение последних двух минут, то Go запустит ее в принудительном порядке  (и нет прямого способа изменить "правило двух минут" для сборки мусора в Go). Нужно проявлять осторожность в тонкой настройке значения GOGC. На пиковых нагрузках можно применять трюк: `var min = make([]byte, 1_000_000_000)` - принудительно выделит 1 Гбайт, чтобы GC запускался, только когда куча удвоится. А как принудительно запустить, не дожидаясь истечения двух минут: `runtime.GC()`.
// `$ GODEBUG=gctrace=1 go test -bench=. -v` - трассировка GC; а как её посмотреть?
// errors.Join()
// go clean --modcache - как очистить кэш модулей
// TestLogin_FailCases - применение табличных тестов отдельно для FailCases, т.к. они лучше подходят для обобщения
// `return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { ctx := context.WithValue(r.Context(), errorKey, ErrInvalidToken); next.ServeHTTP(w, r.WithContext(ctx)) }` - пример применения context.WithValue внутри http middleware для передачи сообщения об ошибке
// runtime.LockOSThread() лочит P на M неразмывая кеши ядра и т.п.
// геттеры-сеттеры применяются без префикса Get для геттера и с префиксом Set для сеттера
// в чем разница между pipeline и builder? Паттерн "Строитель" скрывает объект до тех пор, пока он не построен до конца (т.е. можно сказать, что builder - это pipeline за закрытыми дверями; хотя оба паттерна имеют дело с последовательностью шагов, они используются в разных сценариях и служат разным целям).
// fmt.Scanln() - is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.
// path := `C:\Users\temp\test.txt` - сырые строки (raw strings) заключаются в обратные кавычки, т.е. экранирование не требуется.
// var _ sql.Scanner = (*Time)(nil) - способ задать компилятору требование реализовать методы интерфейса sql.Scanner (Compile time checks to ensure your type satisfies an interface)[https://medium.com/@matryer/golang-tip-compile-time-checks-to-ensure-your-type-satisfies-an-interface-c167afed3aae]
// соглашение: функция-конструктор не может принимать контекст и возвращать err, потому для testcontainers-go запускаю контейнер в фунции с префиксом "run", т.е. runContainer(ctx context.Context) (*tc.PostgresContainer, error)
// если тебе "что-то" мешает написать тест, значит это "что-то" не на своём месте
// если у тебя в конструктор проброшен контекст, то что-то идет не так
// fmt.Println("Процесс с PID", pid, "успешно завершен.") - можно просто вставлять переменные без форматирования строки
// accept interfaces, return concrete types
```
